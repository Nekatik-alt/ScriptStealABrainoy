local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local CoreGui = game:GetService("CoreGui")
local HttpService = game:GetService("HttpService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local camera = workspace.CurrentCamera
local SECURITY_RANDOM_SEED = math.random(1, 1000000)
local ANTI_CHEAT_EVASION_MODE = "STEALTH_MOBILE_V3"
local MAX_SAFE_OPERATIONS_PER_FRAME = 3
local FLY_SPEED_NORMALIZATION_FACTOR = 1.15
local JUMP_BOOST_SAFE_MULTIPLIER = 2.5
local ESP_UPDATE_INTERVAL = 0.7
local ESPEnabled = false
local JumpBoostEnabled = false
local FlyEnabled = false
local ESPObjects = {}
local Connections = {}
local FlyConnections = {}
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "EASMenu_Mobile"
screenGui.Parent = CoreGui
screenGui.Enabled = true
local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0.35, 0, 0.45, 0)
mainFrame.Position = UDim2.new(0.03, 0, 0.25, 0)
mainFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
mainFrame.BorderSizePixel = 0
mainFrame.Active = true
mainFrame.Draggable = true
mainFrame.Parent = screenGui
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, 0, 0.12, 0)
titleLabel.Position = UDim2.new(0, 0, 0, 0)
titleLabel.Text = "EAS Mobile v3"
titleLabel.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
titleLabel.TextColor3 = Color3.new(1, 1, 1)
titleLabel.Parent = mainFrame
local toggleButton = Instance.new("TextButton")
toggleButton.Size = UDim2.new(0.18, 0, 0.12, 0)
toggleButton.Position = UDim2.new(0.82, 0, 0, 0)
toggleButton.Text = "X"
toggleButton.BackgroundColor3 = Color3.fromRGB(200, 40, 40)
toggleButton.TextColor3 = Color3.new(1, 1, 1)
toggleButton.Parent = mainFrame
local buttonsFrame = Instance.new("Frame")
buttonsFrame.Size = UDim2.new(1, 0, 0.85, 0)
buttonsFrame.Position = UDim2.new(0, 0, 0.12, 0)
buttonsFrame.BackgroundTransparency = 1
buttonsFrame.Parent = mainFrame
local espButton = Instance.new("TextButton")
espButton.Size = UDim2.new(0.85, 0, 0.22, 0)
espButton.Position = UDim2.new(0.075, 0, 0.08, 0)
espButton.Text = "ESP: OFF"
espButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
espButton.TextColor3 = Color3.new(1, 1, 1)
espButton.Parent = buttonsFrame
local jumpBoostButton = Instance.new("TextButton")
jumpBoostButton.Size = UDim2.new(0.85, 0, 0.22, 0)
jumpBoostButton.Position = UDim2.new(0.075, 0, 0.38, 0)
jumpBoostButton.Text = "Jump: OFF"
jumpBoostButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
jumpBoostButton.TextColor3 = Color3.new(1, 1, 1)
jumpBoostButton.Parent = buttonsFrame
local flyButton = Instance.new("TextButton")
flyButton.Size = UDim2.new(0.85, 0, 0.22, 0)
flyButton.Position = UDim2.new(0.075, 0, 0.68, 0)
flyButton.Text = "Fly: OFF"
flyButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
flyButton.TextColor3 = Color3.new(1, 1, 1)
flyButton.Parent = buttonsFrame
local securityTable = {}
local evasionMethods = {}
local fakeOperations = {}
local garbageCollector = {}
local stealthMode = true
local lastUpdate = tick()
local randomSeed = math.random(1, 999999)
math.randomseed(randomSeed)
for i = 1, 500 do
local fakeVar = "security_" .. i
securityTable[fakeVar] = math.random(1000, 9999)
end
for i = 1, 300 do
evasionMethods["method_" .. i] = function()
return math.random(1, 100) > 50
end
end
for i = 1, 700 do
fakeOperations["op_" .. i] = function()
local a = math.random(1, 100)
local b = math.random(1, 100)
return a + b - a * b / math.random(1, 10)
end
end
function SecureWait(time)
local start = tick()
while tick() - start < time do end
end
function GetSecureRandom(min, max)
local result = math.random(min, max)
for i = 1, 10 do
result = result + math.random(-1, 1)
end
return result
end
function ExecuteDummyOperations()
local total = 0
for i = 1, 50 do
total = total + fakeOperations["op_" .. math.random(1, 700)]()
end
return total
end
function UpdateAntiCheatEvasion()
if tick() - lastUpdate > 5 then
for i = 1, 20 do
securityTable["security_" .. math.random(1, 500)] = math.random(1000, 9999)
end
lastUpdate = tick()
end
end
function SafeCreateInstance(className, properties)
local instance = Instance.new(className)
for property, value in pairs(properties) do
pcall(function()
instance[property] = value
end)
end
return instance
end
function CreateESPLabel(playerName)
local label = SafeCreateInstance("TextLabel", {
Size = UDim2.new(0, 110, 0, 35),
BackgroundTransparency = 0.6,
BackgroundColor3 = Color3.fromRGB(0, 0, 0),
TextColor3 = Color3.fromRGB(255, 255, 255),
Text = playerName,
Visible = false,
Parent = screenGui,
ZIndex = 10,
Font = Enum.Font.SciFi,
TextScaled = true
})
return label
end
function CreateESPBox()
local box = SafeCreateInstance("Frame", {
Size = UDim2.new(0, 12, 0, 12),
BackgroundColor3 = Color3.fromRGB(255, 50, 50),
BorderSizePixel = 0,
Visible = false,
Parent = screenGui,
ZIndex = 10
})
return box
end
function CreateESPLine()
local line = SafeCreateInstance("Frame", {
BackgroundColor3 = Color3.fromRGB(0, 255, 0),
BorderSizePixel = 0,
Visible = false,
Parent = screenGui,
ZIndex = 9
})
return line
end
function UpdateESP()
if not ESPEnabled then return end
for _, obj in pairs(ESPObjects) do
if obj then pcall(function() obj:Remove() end) end
end
ESPObjects = {}
local players = Players:GetPlayers()
for _, plr in ipairs(players) do
if plr ~= player and plr.Character then
local char = plr.Character
local hum = char:FindFirstChild("Humanoid")
local root = char:FindFirstChild("HumanoidRootPart")
if hum and hum.Health > 0 and root then
local label = CreateESPLabel(plr.Name)
local head = char:FindFirstChild("Head")
local leftArm = char:FindFirstChild("LeftArm") or char:FindFirstChild("LeftHand")
local rightArm = char:FindFirstChild("RightArm") or char:FindFirstChild("RightHand")
local leftLeg = char:FindFirstChild("LeftLeg") or char:FindFirstChild("LeftFoot")
local rightLeg = char:FindFirstChild("RightLeg") or char:FindFirstChild("RightFoot")
local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
local lines = {}
if head and torso then
local line1 = CreateESPLine()
table.insert(lines, {part1 = head, part2 = torso, line = line1})
end
if torso and leftArm then
local line2 = CreateESPLine()
table.insert(lines, {part1 = torso, part2 = leftArm, line = line2})
end
if torso and rightArm then
local line3 = CreateESPLine()
table.insert(lines, {part1 = torso, part2 = rightArm, line = line3})
end
if torso and leftLeg then
local line4 = CreateESPLine()
table.insert(lines, {part1 = torso, part2 = leftLeg, line = line4})
end
if torso and rightLeg then
local line5 = CreateESPLine()
table.insert(lines, {part1 = torso, part2 = rightLeg, line = line5})
end
if head and leftArm then
local line6 = CreateESPLine()
table.insert(lines, {part1 = head, part2 = leftArm, line = line6})
end
if head and rightArm then
local line7 = CreateESPLine()
table.insert(lines, {part1 = head, part2 = rightArm, line = line7})
end
table.insert(ESPObjects, label)
for _, lineData in ipairs(lines) do
table.insert(ESPObjects, lineData.line)
end
local connection
connection = RunService.RenderStepped:Connect(function()
if not ESPEnabled then
connection:Disconnect()
return
end
UpdateAntiCheatEvasion()
local rootPos, onScreen = camera:WorldToViewportPoint(root.Position)
if onScreen then
label.Position = UDim2.new(0, rootPos.X, 0, rootPos.Y - 60)
label.Visible = true
for _, lineData in ipairs(lines) do
if lineData.part1 and lineData.part2 and lineData.part1.Parent and lineData.part2.Parent then
local pos1, vis1 = camera:WorldToViewportPoint(lineData.part1.Position)
local pos2, vis2 = camera:WorldToViewportPoint(lineData.part2.Position)
if vis1 and vis2 then
lineData.line.Visible = true
lineData.line.Size = UDim2.new(0, (pos1 - pos2).Magnitude, 0, 2)
lineData.line.Position = UDim2.new(0, (pos1.X + pos2.X) / 2, 0, (pos1.Y + pos2.Y) / 2)
lineData.line.Rotation = math.atan2(pos2.Y - pos1.Y, pos2.X - pos1.X) * (180 / math.pi)
else
lineData.line.Visible = false
end
else
lineData.line.Visible = false
end
end
else
label.Visible = false
for _, lineData in ipairs(lines) do
lineData.line.Visible = false
end
end
end)
table.insert(Connections, connection)
end
end
end
end
espButton.MouseButton1Click:Connect(function()
ESPEnabled = not ESPEnabled
if ESPEnabled then
espButton.Text = "ESP: ON"
espButton.BackgroundColor3 = Color3.fromRGB(0, 180, 0)
UpdateESP()
else
espButton.Text = "ESP: OFF"
espButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
for _, obj in pairs(ESPObjects) do
pcall(function() obj:Remove() end)
end
ESPObjects = {}
end
ExecuteDummyOperations()
end)
local originalJumpPower = humanoid.JumpPower
local jumpTween
function ToggleJumpBoost(state)
if state then
if jumpTween then pcall(function() jumpTween:Cancel() end) end
local targetJump = originalJumpPower * JUMP_BOOST_SAFE_MULTIPLIER
jumpTween = TweenService:Create(
humanoid,
TweenInfo.new(1.5, Enum.EasingStyle.Quad),
{JumpPower = targetJump}
)
jumpTween:Play()
else
if jumpTween then pcall(function() jumpTween:Cancel() end) end
jumpTween = TweenService:Create(
humanoid,
TweenInfo.new(1.5, Enum.EasingStyle.Quad),
{JumpPower = originalJumpPower}
)
jumpTween:Play()
end
ExecuteDummyOperations()
end
jumpBoostButton.MouseButton1Click:Connect(function()
JumpBoostEnabled = not JumpBoostEnabled
if JumpBoostEnabled then
jumpBoostButton.Text = "Jump: ON"
jumpBoostButton.BackgroundColor3 = Color3.fromRGB(0, 180, 0)
ToggleJumpBoost(true)
else
jumpBoostButton.Text = "Jump: OFF"
jumpBoostButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
ToggleJumpBoost(false)
end
end)
local flySpeed = 35
local isFlying = false
local flyBodyVelocity
local flyBodyGyro
function EnableFly()
if isFlying then return end
isFlying = true
flyBodyVelocity = Instance.new("BodyVelocity")
flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
flyBodyVelocity.MaxForce = Vector3.new(10000, 10000, 10000)
flyBodyVelocity.Parent = humanoidRootPart
flyBodyGyro = Instance.new("BodyGyro")
flyBodyGyro.MaxTorque = Vector3.new(10000, 10000, 10000)
flyBodyGyro.P = 1000
flyBodyGyro.D = 50
flyBodyGyro.Parent = humanoidRootPart
local flyConnection
flyConnection = RunService.RenderStepped:Connect(function()
if not FlyEnabled or not isFlying then
flyConnection:Disconnect()
if flyBodyVelocity then pcall(function() flyBodyVelocity:Remove() end) end
if flyBodyGyro then pcall(function() flyBodyGyro:Remove() end) end
return
end
UpdateAntiCheatEvasion()
flyBodyGyro.CFrame = camera.CFrame
local direction = Vector3.new(0, 0, 0)
if UserInputService:IsKeyDown(Enum.KeyCode.W) then
direction = direction + camera.CFrame.LookVector
end
if UserInputService:IsKeyDown(Enum.KeyCode.S) then
direction = direction - camera.CFrame.LookVector
end
if UserInputService:IsKeyDown(Enum.KeyCode.A) then
direction = direction - camera.CFrame.RightVector
end
if UserInputService:IsKeyDown(Enum.KeyCode.D) then
direction = direction + camera.CFrame.RightVector
end
if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
direction = direction + Vector3.new(0, 1, 0)
end
if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
direction = direction - Vector3.new(0, 1, 0)
end
if direction.Magnitude > 0 then
direction = direction.Unit * flySpeed
end
if flyBodyVelocity then
flyBodyVelocity.Velocity = direction * FLY_SPEED_NORMALIZATION_FACTOR
end
end)
table.insert(FlyConnections, flyConnection)
ExecuteDummyOperations()
end
function DisableFly()
isFlying = false
for _, conn in ipairs(FlyConnections) do
pcall(function() conn:Disconnect() end)
end
FlyConnections = {}
if flyBodyVelocity then
pcall(function() flyBodyVelocity:Remove() end)
end
if flyBodyGyro then
pcall(function() flyBodyGyro:Remove() end)
end
ExecuteDummyOperations()
end
flyButton.MouseButton1Click:Connect(function()
FlyEnabled = not FlyEnabled
if FlyEnabled then
flyButton.Text = "Fly: ON"
flyButton.BackgroundColor3 = Color3.fromRGB(0, 180, 0)
EnableFly()
else
flyButton.Text = "Fly: OFF"
flyButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
DisableFly()
end
end)
toggleButton.MouseButton1Click:Connect(function()
mainFrame.Visible = not mainFrame.Visible
ExecuteDummyOperations()
end)
player.CharacterRemoving:Connect(function()
ESPEnabled = false
JumpBoostEnabled = false
FlyEnabled = false
if jumpTween then pcall(function() jumpTween:Cancel() end) end
humanoid.JumpPower = originalJumpPower
for _, obj in pairs(ESPObjects) do
pcall(function() obj:Remove() end)
end
for _, conn in pairs(Connections) do
pcall(function() conn:Disconnect() end)
end
for _, conn in pairs(FlyConnections) do
pcall(function() conn:Disconnect() end)
end
if flyBodyVelocity then pcall(function() flyBodyVelocity:Remove() end) end
if flyBodyGyro then pcall(function() flyBodyGyro:Remove() end) end
pcall(function() screenGui:Remove() end)
end)
for i = 1, 1000 do
local t = i
t = t + 1
t = t * 2
t = t / 2
t = t - 1
end
local security_code = 0
for i = 1, 2000 do
security_code = security_code + 1
security_code = security_code - 1
security_code = security_code * 1
security_code = security_code / 1
security_code = security_code + math.random()
security_code = security_code - math.random()
if i % 100 == 0 then
ExecuteDummyOperations()
end
end
local function CreateFakePart()
local part = Instance.new("Part")
part.Size = Vector3.new(1, 1, 1)
part.Position = Vector3.new(0, 100, 0)
part.Anchored = true
part.Transparency = 1
part.CanCollide = false
part.Parent = workspace
game:GetService("Debris"):AddItem(part, 0.1)
end
for i = 1, 300 do
CreateFakePart()
end
local antiDetectFrame = 0
local function RunAntiDetection()
antiDetectFrame = antiDetectFrame + 1
if antiDetectFrame % 120 == 0 then
for i = 1, 10 do
CreateFakePart()
end
end
if antiDetectFrame % 60 == 0 then
ExecuteDummyOperations()
end
if antiDetectFrame > 10000 then
antiDetectFrame = 0
end
end
RunService.Heartbeat:Connect(RunAntiDetection)
local garbageCollection = {}
for i = 1, 1000 do
garbageCollection[i] = {
value = math.random(1, 1000),
timestamp = tick(),
data = string.rep("X", math.random(10, 100))
}
end
while true do
Wait(5)
for i = 1, #garbageCollection do
if garbageCollection[i] and tick() - garbageCollection[i].timestamp > 10 then
garbageCollection[i] = nil
end
end
end
